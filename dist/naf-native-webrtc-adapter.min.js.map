{"version":3,"sources":["webpack:///webpack/bootstrap db260fe89bea15071fb5","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":[],"mappings":"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","file":"naf-native-webrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap db260fe89bea15071fb5","const WebRtcPeer = require(\"./WebRtcPeer\");\n\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nclass NativeWebRtcAdapter {\n  constructor() {\n    if (io === undefined)\n      console.warn('It looks like socket.io has not been loaded before NativeWebRtcAdapter. Please do that.')\n\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n    this.myId = null;\n    this.avgTimeOffset = 0;\n\n    this.peers = {}; // id -> WebRtcPeer\n    this.occupants = {}; // id -> joinTimestamp\n\n    this.audioStreams = {};\n    this.pendingAudioRequest = {};\n\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  setServerUrl(wsUrl) {\n    this.wsUrl = wsUrl;\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n  }\n\n  setWebRtcOptions(options) {\n    if (options.datachannel === false) {\n      NAF.log.error(\n        \"NativeWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\n      );\n    }\n    if (options.audio === true) {\n      this.sendAudio = true;\n    }\n    if (options.video === true) {\n      NAF.log.warn(\"NativeWebRtcAdapter does not support video yet.\");\n    }\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.occupantListener = occupantListener;\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  connect() {\n    const self = this;\n\n    this.updateTimeOffset()\n    .then(() => {\n      if (!self.wsUrl || self.wsUrl === \"/\") {\n        if (location.protocol === \"https:\") {\n          self.wsUrl = \"wss://\" + location.host;\n        } else {\n          self.wsUrl = \"ws://\" + location.host;\n        }\n      }\n  \n      NAF.log.write(\"Attempting to connect to socket.io\");\n      const socket = self.socket = io(self.wsUrl);\n  \n      socket.on(\"connect\", () => {\n        NAF.log.write(\"User connected\", socket.id);\n        self.myId = socket.id;\n        self.joinRoom();\n      });\n  \n      socket.on(\"connectSuccess\", (data) => {\n        const { joinedTime } = data;\n  \n        self.myRoomJoinTime = joinedTime;\n        NAF.log.write(\"Successfully joined room\", self.room, \"at server time\", joinedTime);\n  \n        if (self.sendAudio) {\n          const mediaConstraints = {\n            audio: true,\n            video: false\n          };\n          navigator.mediaDevices.getUserMedia(mediaConstraints)\n          .then(localStream => {\n            self.storeAudioStream(self.myId, localStream);\n            self.connectSuccess(self.myId);\n          })\n          .catch(e => NAF.log.error(e));\n        } else {\n          self.connectSuccess(self.myId);\n        }\n      });\n  \n      socket.on(\"error\", err => {\n        console.error(\"Socket connection failure\", err);\n        self.connectFailure();\n      });\n  \n      socket.on(\"occupantsChanged\", data => {\n        const { occupants } = data;\n        NAF.log.write('occupants changed', data);\n        self.receivedOccupants(occupants);\n      });\n  \n      function receiveData(packet) {\n        const from = packet.from;\n        const type = packet.type;\n        const data = packet.data;\n        if (type === 'ice-candidate') {\n          self.peers[from].handleSignal(data);\n          return;\n        }\n        self.messageListener(from, type, data);\n      }\n  \n      socket.on(\"send\", receiveData);\n      socket.on(\"broadcast\", receiveData);\n    })\n\n\n  }\n\n  joinRoom() {\n    NAF.log.write(\"Joining room\", this.room);\n    this.socket.emit(\"joinRoom\", { room: this.room });\n  }\n\n  receivedOccupants(occupants) {\n    delete occupants[this.myId];\n\n    this.occupants = occupants;\n\n    NAF.log.write('occupants=', occupants);\n    const self = this;\n    const localId = this.myId;\n\n    for (var key in occupants) {\n      const remoteId = key;\n      if (this.peers[remoteId]) continue;\n\n      const peer = new WebRtcPeer(\n        localId,\n        remoteId,\n        (data) => {\n          self.socket.emit('send',{\n            from: localId,\n            to: remoteId,\n            type: 'ice-candidate',\n            data,\n            sending: true,\n          });\n        }\n      );\n      peer.setDatachannelListeners(\n        self.openListener,\n        self.closedListener,\n        self.messageListener,\n        self.trackListener.bind(self)\n      );\n\n      self.peers[remoteId] = peer;\n    }\n\n    this.occupantListener(occupants);\n  }\n\n  shouldStartConnectionTo(client) {\n    return (this.myRoomJoinTime || 0) <= (client || 0);\n  }\n\n  startStreamConnection(remoteId) {\n    NAF.log.write('starting offer process');\n\n    if (this.sendAudio) {\n      this.getMediaStream(this.myId)\n      .then(stream => {\n        const options = {\n          sendAudio: true,\n          localAudioStream: stream,\n        };\n        this.peers[remoteId].offer(options);\n      });\n    } else {\n      this.peers[remoteId].offer({});\n    }\n  }\n\n  closeStreamConnection(clientId) {\n    NAF.log.write('closeStreamConnection', clientId, this.peers);\n    this.peers[clientId].close();\n    delete this.peers[clientId];\n    delete this.occupants[clientId];\n    this.closedListener(clientId);\n  }\n\n  getConnectStatus(clientId) {\n    const peer = this.peers[clientId];\n\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\n\n    switch (peer.getStatus()) {\n      case WebRtcPeer.IS_CONNECTED:\n        return NAF.adapters.IS_CONNECTED;\n\n      case WebRtcPeer.CONNECTING:\n        return NAF.adapters.CONNECTING;\n\n      case WebRtcPeer.NOT_CONNECTED:\n      default:\n        return NAF.adapters.NOT_CONNECTED;\n    }\n  }\n\n  sendData(to, type, data) {\n    this.peers[to].send(type, data);\n  }\n\n  sendDataGuaranteed(to, type, data) {\n    const packet = {\n      from: this.myId,\n      to,\n      type,\n      data,\n      sending: true,\n    };\n\n    this.socket.emit(\"send\", packet);\n  }\n\n  broadcastData(type, data) {\n    for (var clientId in this.peers) {\n      this.sendData(clientId, type, data);\n    }\n  }\n\n  broadcastDataGuaranteed(type, data) {\n    const packet = {\n      from: this.myId,\n      type,\n      data,\n      broadcasting: true\n    };\n    this.socket.emit(\"broadcast\", packet);\n  }\n\n  storeAudioStream(clientId, stream) {\n    this.audioStreams[clientId] = stream;\n    if (this.pendingAudioRequest[clientId]) {\n      NAF.log.write(\"Received pending audio for \" + clientId);\n      this.pendingAudioRequest[clientId](stream);\n      delete this.pendingAudioRequest[clientId](stream);\n    }\n  }\n\n  trackListener(clientId, stream) {\n    this.storeAudioStream(clientId, stream);\n  }\n\n  getMediaStream(clientId) {\n    var that = this;\n    if (this.audioStreams[clientId]) {\n      NAF.log.write(\"Already had audio for \" + clientId);\n      return Promise.resolve(this.audioStreams[clientId]);\n    } else {\n      NAF.log.write(\"Waiting on audio for \" + clientId);\n      return new Promise(resolve => {\n        that.pendingAudioRequest[clientId] = resolve;\n      });\n    }\n  }\n\n  updateTimeOffset() {\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  getServerTime() {\n    return -1; // TODO implement\n  }\n}\n\nNAF.adapters.register(\"native-webrtc\", NativeWebRtcAdapter);\n\nmodule.exports = NativeWebRtcAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","class WebRtcPeer {\n  constructor(localId, remoteId, sendSignalFunc) {\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  setDatachannelListeners(openListener, closedListener, messageListener, trackListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n    this.trackListener = trackListener;\n  }\n\n  offer(options) {\n    var self = this;\n    // reliable: false - UDP\n    this.setupChannel(\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\n    );\n\n    // If there are errors with Safari implement this:\n    // https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/OpenViduInternal/WebRtcPeer/WebRtcPeer.ts#L154\n    \n    if (options.sendAudio) {\n      options.localAudioStream.getTracks().forEach(\n        track => self.pc.addTrack(track, options.localAudioStream));\n    }\n\n    this.pc.createOffer(\n      sdp => {\n        self.handleSessionDescription(sdp);\n      },\n      error => {\n        NAF.log.error(\"WebRtcPeer.offer: \" + error);\n      },\n      {\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      }\n    );\n  }\n\n  handleSignal(signal) {\n    // ignores signal if it isn't for me\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n    switch (signal.type) {\n      case \"offer\":\n        this.handleOffer(signal);\n        break;\n\n      case \"answer\":\n        this.handleAnswer(signal);\n        break;\n\n      case \"candidate\":\n        this.handleCandidate(signal);\n        break;\n\n      default:\n        NAF.log.error(\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\n        );\n        break;\n    }\n  }\n\n  send(type, data) {\n    if (this.channel === null || this.channel.readyState !== \"open\") {\n      return;\n    }\n\n    this.channel.send(JSON.stringify({ type: type, data: data }));\n  }\n\n  getStatus() {\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n    switch (this.channel.readyState) {\n      case \"open\":\n        return WebRtcPeer.IS_CONNECTED;\n\n      case \"connecting\":\n        return WebRtcPeer.CONNECTING;\n\n      case \"closing\":\n      case \"closed\":\n      default:\n        return WebRtcPeer.NOT_CONNECTED;\n    }\n  }\n\n  /*\n   * Privates\n   */\n\n  createPeerConnection() {\n    var self = this;\n    var RTCPeerConnection =\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection ||\n      window.msRTCPeerConnection;\n\n    if (RTCPeerConnection === undefined) {\n      throw new Error(\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\n      );\n    }\n\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\n\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        self.sendSignalFunc({\n          from: self.localId,\n          to: self.remoteId,\n          type: \"candidate\",\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          candidate: event.candidate.candidate\n        });\n      }\n    };\n\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\n    //       so also tries to detect disconnection here.\n    pc.oniceconnectionstatechange = function() {\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }\n    };\n\n    pc.ontrack = (e) => {\n      self.trackListener(self.remoteId, e.streams[0]);\n    }\n\n    return pc;\n  }\n\n  setupChannel(channel) {\n    var self = this;\n\n    this.channel = channel;\n\n    // received data from a remote peer\n    this.channel.onmessage = function(event) {\n      var data = JSON.parse(event.data);\n      self.messageListener(self.remoteId, data.type, data.data);\n    };\n\n    // connected with a remote peer\n    this.channel.onopen = function(event) {\n      self.open = true;\n      self.openListener(self.remoteId);\n    };\n\n    // disconnected with a remote peer\n    this.channel.onclose = function(event) {\n      if (!self.open) return;\n      self.open = false;\n      self.closedListener(self.remoteId);\n    };\n\n    // error occurred with a remote peer\n    this.channel.onerror = function(error) {\n      NAF.log.error(\"WebRtcPeer.channel.onerror: \" + error);\n    };\n  }\n\n  handleOffer(message) {\n    var self = this;\n\n    this.pc.ondatachannel = function(event) {\n      self.setupChannel(event.channel);\n    };\n\n    this.setRemoteDescription(message);\n\n    this.pc.createAnswer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleOffer: \" + error);\n      }\n    );\n  }\n\n  handleAnswer(message) {\n    this.setRemoteDescription(message);\n  }\n\n  handleCandidate(message) {\n    var self = this;\n    var RTCIceCandidate =\n      window.RTCIceCandidate ||\n      window.webkitRTCIceCandidate ||\n      window.mozRTCIceCandidate;\n\n    this.pc.addIceCandidate(\n      new RTCIceCandidate(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleCandidate: \" + error);\n      }\n    );\n  }\n\n  handleSessionDescription(sdp) {\n    var self = this;\n\n    this.pc.setLocalDescription(\n      sdp,\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      }\n    );\n\n    this.sendSignalFunc({\n      from: this.localId,\n      to: this.remoteId,\n      type: sdp.type,\n      sdp: sdp.sdp\n    });\n  }\n\n  setRemoteDescription(message) {\n    var self = this;\n    var RTCSessionDescription =\n      window.RTCSessionDescription ||\n      window.webkitRTCSessionDescription ||\n      window.mozRTCSessionDescription ||\n      window.msRTCSessionDescription;\n\n    this.pc.setRemoteDescription(\n      new RTCSessionDescription(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      }\n    );\n  }\n\n  close() {\n    if (this.pc) {\n      this.pc.close();\n    }\n  }\n}\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\n\nWebRtcPeer.ICE_SERVERS = [\n  { urls: \"stun:stun1.l.google.com:19302\" },\n  { urls: \"stun:stun2.l.google.com:19302\" },\n  { urls: \"stun:stun3.l.google.com:19302\" },\n  { urls: \"stun:stun4.l.google.com:19302\" }\n];\n\nmodule.exports = WebRtcPeer;\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}