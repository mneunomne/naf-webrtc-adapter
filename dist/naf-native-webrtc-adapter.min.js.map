{"version":3,"sources":["webpack:///webpack/bootstrap 0c37ec3fb20ba9f28ee1","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":["WebRtcPeer","require","NativeWebRtcAdapter","console","wsUrl","appName","roomName","options","successListener","occupantListener","openListener","from","packet","type","data","self","location","socket","io","room","occupants","NAF","clientId","index","connected","to","sending","broadcasting","Promise","module","signal","JSON","RTCPeerConnection","window","pc","iceServers","event","sdpMLineIndex","candidate","channel","message","RTCIceCandidate","sdp","RTCSessionDescription","urls"],"mappings":"aAIA,cAGA,QACA,oBAGA,YACA,GADA,CAEA,IAFA,CAGA,UAHA,EAaA,MANA,mCAMA,CAHA,MAGA,UACA,CAxBA,SA4DA,MAhCA,MAgCA,CA7BA,KA6BA,CA1BA,oBACA,QADA,EAEA,2BACA,eADA,CAEA,aAFA,CAGA,KAHA,EAMA,CAkBA,CAfA,gBACA,sBACA,WAA2B,mBAA4B,CADvD,CAEA,WAAiC,QAAe,CAFhD,CAIA,MADA,aACA,EACA,CASA,CANA,kBAAsD,gDAA+D,CAMrH,CAHA,MAGA,S,oXC7DMA,EAAaC,EAAnB,CAAmBA,C,CAObC,E,WACJ,YAAc,WAEZ,WAFY,EAGVC,uGAHU,CAKZ,kBALY,CAMZ,mBANY,CAOZ,wBAPY,CAQZ,0BARY,CAUZ,KAVY,KAUZ,GAVY,CAWZ,KAXY,SAWZ,GACD,C,sCAEYC,WAAO,CAClB,YACD,C,sBAEMC,WAAS,CACd,UACD,C,uBAEOC,WAAU,CAChB,WACD,C,gCAEgBC,WAAS,CACpBA,OAAJ,WADwB,EAEtBJ,+EAFsB,CAKpBI,OAAJ,KALwB,EAMtBJ,+DANsB,CAOpBI,OAAJ,KAPwB,EAQtBJ,+DACH,C,yCAEyBK,aAAkC,CAC1D,qBAD0D,CAE1D,qBACD,C,uCAEuBC,WAAkB,CACxC,uBACD,C,uCAEuBC,eAA+C,CACrE,mBADqE,CAErE,qBAFqE,CAGrE,sBACD,C,iCAES,CAmCR,aAA6B,IACrBC,GAAOC,EAAb,IAD2B,CAErBC,EAAOD,EAAb,IAF2B,CAGrBE,EAAOF,EAAb,IAH2B,CAI3BT,8BAJ2B,CAK3BY,wBACD,CAzCO,WACFA,EAAN,IADQ,CAGH,KAAD,OAAJ,GAAmB,aAHX,GAIN,QAAIC,oBAJE,CAKJ,WAAa,SAAWA,SAAxB,IALI,CAOJ,WAAa,QAAUA,SAAvB,IAPI,EAWRb,iDAXQ,CAYR,GAAMc,GAAS,YAAcC,GAAG,KAAhC,KAA6BA,CAA7B,CAEAD,eAAqB,UAAM,CACzBd,6BAA8Bc,EAA9Bd,GADyB,CAEzBY,YAFFE,EAdQ,CAmBRA,sBAA4B,UAAM,CAChCd,uCAAwC,EAAxCA,KADgC,CAEhCY,iBAAoBE,EAApBF,GAFFE,EAnBQ,CAwBRA,aAAmB,WAAO,CACxBd,4CADwB,CAExBY,kBAFFE,EAxBQ,CA6BRA,wBAA8B,WAAQ,mBAEpCd,kCAFoC,CAGpCY,sBAHFE,EA7BQ,CA2CRA,cA3CQ,CA4CRA,mBACD,C,kCAEU,CACTd,2BAA4B,KAA5BA,KADS,CAET,4BAA6B,CAAEgB,KAAM,KAArC,IAA6B,CAA7B,CACD,C,iCAEiBC,WAAW,CAC3B,MAAOA,GAAUC,IAAjB,QAAOD,CADoB,CAE3B,wBACD,C,uCAEuBE,UAAU,SAEjC,C,qCAEqBA,WAAU,CAC9B,6BAD8B,CAE9B,oBACD,C,qCAEqBA,WAAU,CAC9B,GAAMC,GAAQ,sBAAd,OAAc,GAAd,CACY,CAAZ,CAAIA,EAF0B,EAG5B,iCAH4B,CAK9B,sBACD,C,gCAEgBD,WAAU,CACzB,GAAME,GAAuD,CAA7D,CAAkB,kCAAlB,CADyB,SAIhBH,aAAP,YAJuB,CAMhBA,aAAP,aAEH,C,wBAEQI,eAAgB,CACvB,8BACD,C,kCAEkBA,eAAgB,CACjC,GAAMb,GAAS,CACbD,KAAMU,IADO,4BAKbK,UALa,CAAf,CAQA,0BACD,C,6BAEab,aAAY,CACxB,iCACD,C,uCAEuBA,aAAY,CAClC,GAAMD,GAAS,CACbD,KAAMU,IADO,uBAIbM,eAJa,CAAf,CAMA,+BACD,C,8BAEcL,UAAU,CAAE,MAAOM,gBAAP,kDAAOA,CAAmE,C,uCAErF,CACd,MAAO,CADO,CAEf,C,SAGHP,wC,CAEAQ,W,8WCvLM7B,E,WACJ,iBAA+C,WAC7C,cAD6C,CAE7C,eAF6C,CAG7C,qBAH6C,CAI7C,YAJ6C,CAK7C,4CAL6C,CAO7C,QAAU,KAAV,oBAAU,EAPmC,CAQ7C,iBACD,C,iDAEuBU,eAA+C,CACrE,mBADqE,CAErE,qBAFqE,CAGrE,sBACD,C,+BAEO,CACN,GAAIK,GAAJ,KAEA,kBACE,0BAA0B,KAA1B,aAA6C,CAD/C,WAC+C,CAA7C,CADF,CAHM,CAMN,oBACE,WAAc,CACZA,6BAFJ,EAIE,WAAgB,CACdZ,qCALJ,EAQD,C,4BAEY2B,WAAQ,CAEnB,GAAI,eAAiBA,EAAjB,IAA8B,gBAAkBA,EAApD,KAEA,OAAQA,EAAR,MACE,YACE,mBADF,CAEE,MAEF,aACE,oBADF,CAEE,MAEF,gBACE,uBADF,CAEE,MAEF,QACE3B,cACE,gDAAkD2B,EADpD3B,KADF,CAbF,CAmBD,C,oBAEIU,aAAY,CAEX,qBAAJ,MAA6B,0BAFd,EAIf,kBAAkBkB,eAAe,QAAjC,MAAiC,CAAfA,CAAlB,CACD,C,mCAEW,CACV,OAAI,eAAJ,CAA2B,MAAO/B,GAAP,cAE3B,OAAQ,aAAR,YACE,WACE,MAAOA,GAAP,aAEF,iBACE,MAAOA,GAAP,WAEF,cACA,aACA,QACE,MAAOA,GAAP,cAVJ,CAYD,C,8CAMsB,IACjBe,GAAJ,IADqB,CAEjBiB,EACFC,0BACAA,OADAA,yBAEAA,OAFAA,sBAGAA,OAJF,mBAFqB,CAQrB,cACE,KAAM,WAAN,gFAAM,CAAN,CAKF,GAAIC,GAAK,MAAsB,CAAEC,WAAYnC,EAA7C,WAA+B,CAAtB,CAAT,CAuBA,MArBAkC,kBAAoB,WAAgB,CAC9BE,EAAJ,SADkC,EAEhCrB,iBAAoB,CAClBJ,KAAMI,EADY,QAElBU,GAAIV,EAFc,SAGlBF,KAHkB,YAIlBwB,cAAeD,YAJG,cAKlBE,UAAWF,YAAgBE,SALT,CAApBvB,CAFJmB,CAqBA,CAPAA,6BAAgC,UAAW,CACrCnB,QAAJ,cAAiBmB,uBADwB,GAEvCnB,SAFuC,CAGvCA,iBAAoBA,EAApBA,SAHuC,CAA3CmB,CAOA,EACD,C,4BAEYK,WAAS,CACpB,GAAIxB,GAAJ,KAEA,cAHoB,CAMpB,uBAAyB,WAAgB,CACvC,GAAID,GAAOiB,WAAWK,EAAtB,IAAWL,CAAX,CACAhB,kBAAqBA,EAArBA,SAAoCD,EAApCC,KAA+CD,EAA/CC,KAFF,CANoB,CAYpB,oBAAsB,UAAgB,CACpCA,SADoC,CAEpCA,eAAkBA,EAAlBA,SAFF,CAZoB,CAkBpB,qBAAuB,UAAgB,CAChCA,EAAL,IADqC,GAErCA,SAFqC,CAGrCA,iBAAoBA,EAApBA,SAHqC,CAAvC,CAlBoB,CAyBpB,qBAAuB,WAAgB,CACrCZ,+CADF,CAGD,C,2BAEWqC,WAAS,CACnB,GAAIzB,GAAJ,KAEA,sBAAwB,WAAgB,CACtCA,eAAkBqB,EAAlBrB,QADF,CAHmB,CAOnB,4BAPmB,CASnB,qBACE,WAAc,CACZA,6BAFJ,EAIE,WAAgB,CACdZ,2CALJ,EAQD,C,4BAEYqC,WAAS,CACpB,4BACD,C,+BAEeA,WAAS,IACnBzB,GAAJ,IADuB,CAEnB0B,EACFR,wBACAA,OADAA,uBAEAA,OAHF,kBAFuB,CAOvB,iCAEE,UAAW,CAFb,EAGE,WAAgB,CACd9B,+CAJJ,EAOD,C,wCAEwBuC,WAAK,CAC5B,IAD4B,CAG5B,8BAEE,UAAW,CAFb,EAGE,WAAgB,CACdvC,wDAJJ,EAH4B,CAW5B,oBAAoB,CAClBQ,KAAM,KADY,QAElBc,GAAI,KAFc,SAGlBZ,KAAM6B,EAHY,KAIlBA,IAAKA,EAAIA,GAJS,CAApB,CAMD,C,oCAEoBF,WAAS,IACxBzB,GAAJ,IAD4B,CAExB4B,EACFV,8BACAA,OADAA,6BAEAA,OAFAA,0BAGAA,OAJF,uBAF4B,CAQ5B,sCAEE,UAAW,CAFb,EAGE,WAAgB,CACd9B,oDAJJ,EAOD,C,SAGHH,6B,CACAA,yB,CACAA,+B,CAEAA,cAAyB,CACvB,CAAE4C,KADqB,+BACvB,CADuB,CAEvB,CAAEA,KAFqB,+BAEvB,CAFuB,CAGvB,CAAEA,KAHqB,+BAGvB,CAHuB,CAIvB,CAAEA,KAJJ5C,+BAIE,CAJuB,C,CAOzB6B,W","file":"naf-native-webrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0c37ec3fb20ba9f28ee1","const WebRtcPeer = require(\"./WebRtcPeer\");\n\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nclass NativeWebRtcAdapter {\n  constructor() {\n\n    if (io === undefined)\n      console.warn('It looks like socket.io has not been loaded before NativeWebRtcAdapter. Please do that.')\n\n    this.app = \"default\";\n    this.room = \"default\";\n    this.connectedClients = [];\n    this.occupantListener = null;\n\n    this.peers = {}; // id -> WebRtcPeer\n    this.occupants = {}; // id -> TODO: joinTimestamp\n  }\n\n  setServerUrl(wsUrl) {\n    this.wsUrl = wsUrl;\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n  }\n\n  setWebRtcOptions(options) {\n    if (options.datachannel === false)\n      console.warn(\n        \"NativeWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\n      );\n    if (options.audio === true)\n      console.warn(\"NativeWebRtcAdapter does not support audio yet.\");\n    if (options.video === true)\n      console.warn(\"NativeWebRtcAdapter does not support video yet.\");\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.occupantListener = occupantListener;\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  connect() {\n    const self = this;\n\n    if (!this.wsUrl || this.wsUrl === \"/\") {\n      if (location.protocol === \"https:\") {\n        this.wsUrl = \"wss://\" + location.host;\n      } else {\n        this.wsUrl = \"ws://\" + location.host;\n      }\n    }\n\n    console.log(\"Attempting to connect to socket.io\");\n    const socket = this.socket = io(this.wsUrl);\n\n    socket.on(\"connect\", () => {\n      console.log(\"User connected\", socket.id);\n      self.joinRoom();\n    });\n\n    socket.on(\"connectSuccess\", () => {\n      console.log(\"Successfully joined room\", this.room);\n      self.connectSuccess(socket.id);\n    });\n\n    socket.on(\"error\", err => {\n      console.error(\"Socket connection failure\", err);\n      self.connectFailure();\n    });\n\n    socket.on(\"occupantsChanged\", data => {\n      const { occupants } = data;\n      console.log('occupants changed', data);\n      self.receivedOccupants(occupants);\n    });\n\n    function receiveData(packet) {\n      const from = packet.from;\n      const type = packet.type;\n      const data = packet.data;\n      console.log('received data', packet);\n      self.messageListener(from, type, data);\n    }\n\n    socket.on(\"send\", receiveData);\n    socket.on(\"broadcast\", receiveData);\n  }\n\n  joinRoom() {\n    console.log(\"Joining room\", this.room);\n    this.socket.emit(\"joinRoom\", { room: this.room });\n  }\n\n  receivedOccupants(occupants) {\n    delete occupants[NAF.clientId];\n    this.occupantListener(occupants);\n  }\n\n  shouldStartConnectionTo(clientId) {\n    return true; // Handled elsewhere\n  }\n\n  startStreamConnection(clientId) {\n    this.connectedClients.push(clientId);\n    this.openListener(clientId);\n  }\n\n  closeStreamConnection(clientId) {\n    const index = this.connectedClients.indexOf(clientId);\n    if (index > -1) {\n      this.connectedClients.splice(index, 1);\n    }\n    this.closedListener(clientId);\n  }\n\n  getConnectStatus(clientId) {\n    const connected = this.connectedClients.indexOf(clientId) != -1;\n\n    if (connected) {\n      return NAF.adapters.IS_CONNECTED;\n    } else {\n      return NAF.adapters.NOT_CONNECTED;\n    }\n  }\n\n  sendData(to, type, data) {\n    this.sendDataGuaranteed(to, type, data);\n  }\n\n  sendDataGuaranteed(to, type, data) {\n    const packet = {\n      from: NAF.clientId,\n      to,\n      type,\n      data,\n      sending: true,\n    };\n\n    this.socket.emit(\"send\", packet);\n  }\n\n  broadcastData(type, data) {\n    this.broadcastDataGuaranteed(type, data);\n  }\n\n  broadcastDataGuaranteed(type, data) {\n    const packet = {\n      from: NAF.clientId,\n      type,\n      data,\n      broadcasting: true\n    };\n    this.socket.emit(\"broadcast\", packet);\n  }\n\n  getMediaStream(clientId) { return Promise.reject('Interface method not implemented: getMediaStream')}\n\n  getServerTime() {\n    return -1; // TODO implement\n  }\n}\n\nNAF.adapters.register(\"native-webrtc\", NativeWebRtcAdapter);\n\nmodule.exports = NativeWebRtcAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","class WebRtcPeer {\n  constructor(localId, remoteId, sendSignalFunc) {\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  setDatachannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  offer() {\n    var self = this;\n    // reliable: false - UDP\n    this.setupChannel(\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\n    );\n    this.pc.createOffer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        console.error(\"WebRtcPeer.offer: \" + error);\n      }\n    );\n  }\n\n  handleSignal(signal) {\n    // ignores signal if it isn't for me\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n    switch (signal.type) {\n      case \"offer\":\n        this.handleOffer(signal);\n        break;\n\n      case \"answer\":\n        this.handleAnswer(signal);\n        break;\n\n      case \"candidate\":\n        this.handleCandidate(signal);\n        break;\n\n      default:\n        console.error(\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\n        );\n        break;\n    }\n  }\n\n  send(type, data) {\n    // TODO: throw error?\n    if (this.channel === null || this.channel.readyState !== \"open\") return;\n\n    this.channel.send(JSON.stringify({ type: type, data: data }));\n  }\n\n  getStatus() {\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n    switch (this.channel.readyState) {\n      case \"open\":\n        return WebRtcPeer.IS_CONNECTED;\n\n      case \"connecting\":\n        return WebRtcPeer.CONNECTING;\n\n      case \"closing\":\n      case \"closed\":\n      default:\n        return WebRtcPeer.NOT_CONNECTED;\n    }\n  }\n\n  /*\n     * Privates\n     */\n\n  createPeerConnection() {\n    var self = this;\n    var RTCPeerConnection =\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection ||\n      window.msRTCPeerConnection;\n\n    if (RTCPeerConnection === undefined) {\n      throw new Error(\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\n      );\n    }\n\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\n\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        self.sendSignalFunc({\n          from: self.localId,\n          to: self.remoteId,\n          type: \"candidate\",\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          candidate: event.candidate.candidate\n        });\n      }\n    };\n\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\n    //       so also tries to detect disconnection here.\n    pc.oniceconnectionstatechange = function() {\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }\n    };\n\n    return pc;\n  }\n\n  setupChannel(channel) {\n    var self = this;\n\n    this.channel = channel;\n\n    // received data from a remote peer\n    this.channel.onmessage = function(event) {\n      var data = JSON.parse(event.data);\n      self.messageListener(self.remoteId, data.type, data.data);\n    };\n\n    // connected with a remote peer\n    this.channel.onopen = function(event) {\n      self.open = true;\n      self.openListener(self.remoteId);\n    };\n\n    // disconnected with a remote peer\n    this.channel.onclose = function(event) {\n      if (!self.open) return;\n      self.open = false;\n      self.closedListener(self.remoteId);\n    };\n\n    // error occurred with a remote peer\n    this.channel.onerror = function(error) {\n      console.error(\"WebRtcPeer.channel.onerror: \" + error);\n    };\n  }\n\n  handleOffer(message) {\n    var self = this;\n\n    this.pc.ondatachannel = function(event) {\n      self.setupChannel(event.channel);\n    };\n\n    this.setRemoteDescription(message);\n\n    this.pc.createAnswer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        console.error(\"WebRtcPeer.handleOffer: \" + error);\n      }\n    );\n  }\n\n  handleAnswer(message) {\n    this.setRemoteDescription(message);\n  }\n\n  handleCandidate(message) {\n    var self = this;\n    var RTCIceCandidate =\n      window.RTCIceCandidate ||\n      window.webkitRTCIceCandidate ||\n      window.mozRTCIceCandidate;\n\n    this.pc.addIceCandidate(\n      new RTCIceCandidate(message),\n      function() {},\n      function(error) {\n        console.error(\"WebRtcPeer.handleCandidate: \" + error);\n      }\n    );\n  }\n\n  handleSessionDescription(sdp) {\n    var self = this;\n\n    this.pc.setLocalDescription(\n      sdp,\n      function() {},\n      function(error) {\n        console.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      }\n    );\n\n    this.sendSignalFunc({\n      from: this.localId,\n      to: this.remoteId,\n      type: sdp.type,\n      sdp: sdp.sdp\n    });\n  }\n\n  setRemoteDescription(message) {\n    var self = this;\n    var RTCSessionDescription =\n      window.RTCSessionDescription ||\n      window.webkitRTCSessionDescription ||\n      window.mozRTCSessionDescription ||\n      window.msRTCSessionDescription;\n\n    this.pc.setRemoteDescription(\n      new RTCSessionDescription(message),\n      function() {},\n      function(error) {\n        console.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      }\n    );\n  }\n}\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\n\nWebRtcPeer.ICE_SERVERS = [\n  { urls: \"stun:stun1.l.google.com:19302\" },\n  { urls: \"stun:stun2.l.google.com:19302\" },\n  { urls: \"stun:stun3.l.google.com:19302\" },\n  { urls: \"stun:stun4.l.google.com:19302\" }\n];\n\nmodule.exports = WebRtcPeer;\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}