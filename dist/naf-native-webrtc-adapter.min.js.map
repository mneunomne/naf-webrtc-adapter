{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":["WebRtcPeer","require","NativeWebRtcAdapter","console","this","app","room","occupantListener","myRoomJoinTime","myId","avgTimeOffset","audioStreams","pendingAudioRequest","serverTimeRequests","timeOffsets","wsUrl","appName","roomName","options","NAF","sendAudio","successListener","connectSuccess","connectFailure","openListener","closedListener","messageListener","self","updateTimeOffset","from","packet","type","data","location","socket","io","navigator","video","emit","occupants","localId","peer","sending","client","remoteId","getMediaStream","localAudioStream","peers","clientId","to","sendData","c","broadcasting","storeAudioStream","that","Promise","clientSentTime","Date","fetch","document","method","cache","serverReceivedTime","res","precision","clientReceivedTime","timeOffset","setTimeout","module","sendSignalFunc","open","channelLabel","pc","channel","trackListener","setupChannel","createDataChannel","createOffer","offerToReceiveVideo","signal","handleOffer","handleAnswer","handleCandidate","send","JSON","RTCPeerConnection","window","iceServers","event","sdpMLineIndex","candidate","e","onmessage","onopen","onclose","onerror","message","ondatachannel","setRemoteDescription","createAnswer","RTCIceCandidate","addIceCandidate","sdp","setLocalDescription","RTCSessionDescription","close","urls"],"mappings":"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","file":"naf-native-webrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const WebRtcPeer = require(\"./WebRtcPeer\");\n\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nclass NativeWebRtcAdapter {\n  constructor() {\n    if (io === undefined)\n      console.warn('It looks like socket.io has not been loaded before NativeWebRtcAdapter. Please do that.')\n\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n    this.myId = null;\n    this.avgTimeOffset = 0;\n\n    this.peers = {}; // id -> WebRtcPeer\n    this.occupants = {}; // id -> joinTimestamp\n\n    this.audioStreams = {};\n    this.pendingAudioRequest = {};\n\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  setServerUrl(wsUrl) {\n    this.wsUrl = wsUrl;\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n  }\n\n  setWebRtcOptions(options) {\n    if (options.datachannel === false) {\n      NAF.log.error(\n        \"NativeWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\n      );\n    }\n    if (options.audio === true) {\n      this.sendAudio = true;\n    }\n    if (options.video === true) {\n      NAF.log.warn(\"NativeWebRtcAdapter does not support video yet.\");\n    }\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.occupantListener = occupantListener;\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  connect() {\n    const self = this;\n\n    this.updateTimeOffset()\n    .then(() => {\n      if (!self.wsUrl || self.wsUrl === \"/\") {\n        if (location.protocol === \"https:\") {\n          self.wsUrl = \"wss://\" + location.host;\n        } else {\n          self.wsUrl = \"ws://\" + location.host;\n        }\n      }\n  \n      NAF.log.write(\"Attempting to connect to socket.io\");\n      const socket = self.socket = io(self.wsUrl);\n  \n      socket.on(\"connect\", () => {\n        NAF.log.write(\"User connected\", socket.id);\n        self.myId = socket.id;\n        self.joinRoom();\n      });\n  \n      socket.on(\"connectSuccess\", (data) => {\n        const { joinedTime } = data;\n  \n        self.myRoomJoinTime = joinedTime;\n        NAF.log.write(\"Successfully joined room\", self.room, \"at server time\", joinedTime);\n  \n        if (self.sendAudio) {\n          const mediaConstraints = {\n            audio: true,\n            video: false\n          };\n          navigator.mediaDevices.getUserMedia(mediaConstraints)\n          .then(localStream => {\n            self.storeAudioStream(self.myId, localStream);\n            self.connectSuccess(self.myId);\n          })\n          .catch(e => NAF.log.error(e));\n        } else {\n          self.connectSuccess(self.myId);\n        }\n      });\n  \n      socket.on(\"error\", err => {\n        console.error(\"Socket connection failure\", err);\n        self.connectFailure();\n      });\n  \n      socket.on(\"occupantsChanged\", data => {\n        const { occupants } = data;\n        NAF.log.write('occupants changed', data);\n        self.receivedOccupants(occupants);\n      });\n  \n      function receiveData(packet) {\n        const from = packet.from;\n        const type = packet.type;\n        const data = packet.data;\n        if (type === 'ice-candidate') {\n          self.peers[from].handleSignal(data);\n          return;\n        }\n        self.messageListener(from, type, data);\n      }\n  \n      socket.on(\"send\", receiveData);\n      socket.on(\"broadcast\", receiveData);\n    })\n\n\n  }\n\n  joinRoom() {\n    NAF.log.write(\"Joining room\", this.room);\n    this.socket.emit(\"joinRoom\", { room: this.room });\n  }\n\n  receivedOccupants(occupants) {\n    delete occupants[this.myId];\n\n    this.occupants = occupants;\n\n    NAF.log.write('occupants=', occupants);\n    const self = this;\n    const localId = this.myId;\n\n    for (var key in occupants) {\n      const remoteId = key;\n      if (this.peers[remoteId]) continue;\n\n      const peer = new WebRtcPeer(\n        localId,\n        remoteId,\n        (data) => {\n          self.socket.emit('send',{\n            from: localId,\n            to: remoteId,\n            type: 'ice-candidate',\n            data,\n            sending: true,\n          });\n        }\n      );\n      peer.setDatachannelListeners(\n        self.openListener,\n        self.closedListener,\n        self.messageListener,\n        self.trackListener.bind(self)\n      );\n\n      self.peers[remoteId] = peer;\n    }\n\n    this.occupantListener(occupants);\n  }\n\n  shouldStartConnectionTo(client) {\n    return (this.myRoomJoinTime || 0) <= (client || 0);\n  }\n\n  startStreamConnection(remoteId) {\n    NAF.log.write('starting offer process');\n\n    if (this.sendAudio) {\n      this.getMediaStream(this.myId)\n      .then(stream => {\n        const options = {\n          sendAudio: true,\n          localAudioStream: stream,\n        };\n        this.peers[remoteId].offer(options);\n      });\n    } else {\n      this.peers[remoteId].offer({});\n    }\n  }\n\n  closeStreamConnection(clientId) {\n    NAF.log.write('closeStreamConnection', clientId, this.peers);\n    this.peers[clientId].close();\n    delete this.peers[clientId];\n    delete this.occupants[clientId];\n    this.closedListener(clientId);\n  }\n\n  getConnectStatus(clientId) {\n    const peer = this.peers[clientId];\n\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\n\n    switch (peer.getStatus()) {\n      case WebRtcPeer.IS_CONNECTED:\n        return NAF.adapters.IS_CONNECTED;\n\n      case WebRtcPeer.CONNECTING:\n        return NAF.adapters.CONNECTING;\n\n      case WebRtcPeer.NOT_CONNECTED:\n      default:\n        return NAF.adapters.NOT_CONNECTED;\n    }\n  }\n\n  sendData(to, type, data) {\n    this.peers[to].send(type, data);\n  }\n\n  sendDataGuaranteed(to, type, data) {\n    const packet = {\n      from: this.myId,\n      to,\n      type,\n      data,\n      sending: true,\n    };\n\n    this.socket.emit(\"send\", packet);\n  }\n\n  broadcastData(type, data) {\n    for (var clientId in this.peers) {\n      this.sendData(clientId, type, data);\n    }\n  }\n\n  broadcastDataGuaranteed(type, data) {\n    const packet = {\n      from: this.myId,\n      type,\n      data,\n      broadcasting: true\n    };\n    this.socket.emit(\"broadcast\", packet);\n  }\n\n  storeAudioStream(clientId, stream) {\n    this.audioStreams[clientId] = stream;\n    if (this.pendingAudioRequest[clientId]) {\n      NAF.log.write(\"Received pending audio for \" + clientId);\n      this.pendingAudioRequest[clientId](stream);\n      delete this.pendingAudioRequest[clientId](stream);\n    }\n  }\n\n  trackListener(clientId, stream) {\n    this.storeAudioStream(clientId, stream);\n  }\n\n  getMediaStream(clientId) {\n    var that = this;\n    if (this.audioStreams[clientId]) {\n      NAF.log.write(\"Already had audio for \" + clientId);\n      return Promise.resolve(this.audioStreams[clientId]);\n    } else {\n      NAF.log.write(\"Waiting on audio for \" + clientId);\n      return new Promise(resolve => {\n        that.pendingAudioRequest[clientId] = resolve;\n      });\n    }\n  }\n\n  updateTimeOffset() {\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  getServerTime() {\n    return -1; // TODO implement\n  }\n}\n\nNAF.adapters.register(\"native-webrtc\", NativeWebRtcAdapter);\n\nmodule.exports = NativeWebRtcAdapter;\n","class WebRtcPeer {\n  constructor(localId, remoteId, sendSignalFunc) {\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  setDatachannelListeners(openListener, closedListener, messageListener, trackListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n    this.trackListener = trackListener;\n  }\n\n  offer(options) {\n    var self = this;\n    // reliable: false - UDP\n    this.setupChannel(\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\n    );\n\n    // If there are errors with Safari implement this:\n    // https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/OpenViduInternal/WebRtcPeer/WebRtcPeer.ts#L154\n    \n    if (options.sendAudio) {\n      options.localAudioStream.getTracks().forEach(\n        track => self.pc.addTrack(track, options.localAudioStream));\n    }\n\n    this.pc.createOffer(\n      sdp => {\n        self.handleSessionDescription(sdp);\n      },\n      error => {\n        NAF.log.error(\"WebRtcPeer.offer: \" + error);\n      },\n      {\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      }\n    );\n  }\n\n  handleSignal(signal) {\n    // ignores signal if it isn't for me\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n    switch (signal.type) {\n      case \"offer\":\n        this.handleOffer(signal);\n        break;\n\n      case \"answer\":\n        this.handleAnswer(signal);\n        break;\n\n      case \"candidate\":\n        this.handleCandidate(signal);\n        break;\n\n      default:\n        NAF.log.error(\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\n        );\n        break;\n    }\n  }\n\n  send(type, data) {\n    if (this.channel === null || this.channel.readyState !== \"open\") {\n      return;\n    }\n\n    this.channel.send(JSON.stringify({ type: type, data: data }));\n  }\n\n  getStatus() {\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n    switch (this.channel.readyState) {\n      case \"open\":\n        return WebRtcPeer.IS_CONNECTED;\n\n      case \"connecting\":\n        return WebRtcPeer.CONNECTING;\n\n      case \"closing\":\n      case \"closed\":\n      default:\n        return WebRtcPeer.NOT_CONNECTED;\n    }\n  }\n\n  /*\n   * Privates\n   */\n\n  createPeerConnection() {\n    var self = this;\n    var RTCPeerConnection =\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection ||\n      window.msRTCPeerConnection;\n\n    if (RTCPeerConnection === undefined) {\n      throw new Error(\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\n      );\n    }\n\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\n\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        self.sendSignalFunc({\n          from: self.localId,\n          to: self.remoteId,\n          type: \"candidate\",\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          candidate: event.candidate.candidate\n        });\n      }\n    };\n\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\n    //       so also tries to detect disconnection here.\n    pc.oniceconnectionstatechange = function() {\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }\n    };\n\n    pc.ontrack = (e) => {\n      self.trackListener(self.remoteId, e.streams[0]);\n    }\n\n    return pc;\n  }\n\n  setupChannel(channel) {\n    var self = this;\n\n    this.channel = channel;\n\n    // received data from a remote peer\n    this.channel.onmessage = function(event) {\n      var data = JSON.parse(event.data);\n      self.messageListener(self.remoteId, data.type, data.data);\n    };\n\n    // connected with a remote peer\n    this.channel.onopen = function(event) {\n      self.open = true;\n      self.openListener(self.remoteId);\n    };\n\n    // disconnected with a remote peer\n    this.channel.onclose = function(event) {\n      if (!self.open) return;\n      self.open = false;\n      self.closedListener(self.remoteId);\n    };\n\n    // error occurred with a remote peer\n    this.channel.onerror = function(error) {\n      NAF.log.error(\"WebRtcPeer.channel.onerror: \" + error);\n    };\n  }\n\n  handleOffer(message) {\n    var self = this;\n\n    this.pc.ondatachannel = function(event) {\n      self.setupChannel(event.channel);\n    };\n\n    this.setRemoteDescription(message);\n\n    this.pc.createAnswer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleOffer: \" + error);\n      }\n    );\n  }\n\n  handleAnswer(message) {\n    this.setRemoteDescription(message);\n  }\n\n  handleCandidate(message) {\n    var self = this;\n    var RTCIceCandidate =\n      window.RTCIceCandidate ||\n      window.webkitRTCIceCandidate ||\n      window.mozRTCIceCandidate;\n\n    this.pc.addIceCandidate(\n      new RTCIceCandidate(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleCandidate: \" + error);\n      }\n    );\n  }\n\n  handleSessionDescription(sdp) {\n    var self = this;\n\n    this.pc.setLocalDescription(\n      sdp,\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      }\n    );\n\n    this.sendSignalFunc({\n      from: this.localId,\n      to: this.remoteId,\n      type: sdp.type,\n      sdp: sdp.sdp\n    });\n  }\n\n  setRemoteDescription(message) {\n    var self = this;\n    var RTCSessionDescription =\n      window.RTCSessionDescription ||\n      window.webkitRTCSessionDescription ||\n      window.mozRTCSessionDescription ||\n      window.msRTCSessionDescription;\n\n    this.pc.setRemoteDescription(\n      new RTCSessionDescription(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      }\n    );\n  }\n\n  close() {\n    if (this.pc) {\n      this.pc.close();\n    }\n  }\n}\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\n\nWebRtcPeer.ICE_SERVERS = [\n  { urls: \"stun:stun1.l.google.com:19302\" },\n  { urls: \"stun:stun2.l.google.com:19302\" },\n  { urls: \"stun:stun3.l.google.com:19302\" },\n  { urls: \"stun:stun4.l.google.com:19302\" }\n];\n\nmodule.exports = WebRtcPeer;"],"sourceRoot":""}