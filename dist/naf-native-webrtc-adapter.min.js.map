{"version":3,"sources":["webpack:///webpack/bootstrap 2f76baa1ec32f0b6d240","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":[],"mappings":"YACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,KAIA,2CAGA,aAGA,OACA,OAIA,IAzBA,eA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,yIC7DA,sPAAM,EAAa,EAEnB,GAKM,YACJ,aAAc,GAEZ,QAAW,aACT,QAAQ,KAEV,gGAAK,IACL,eAAK,KACL,eAAK,iBACL,UAAK,eAEL,UACA,cACD,mDAEY,WACX,MACD,8BAEM,WACL,MACD,6BAEO,WACN,MACD,uCAEgB,WACf,CAAI,OAAwB,aAC1B,QAAQ,KAGV,mEAAI,OAAkB,OACpB,QAAQ,KACV,mDAAI,OAAkB,OACpB,QAAQ,KACX,4FAE0C,aACzC,MACA,sBACD,wDAEuB,WACtB,MACD,0DAEqD,eACpD,MACA,oBACA,sBACD,mDAES,CAsCa,aACnB,IAAM,GAAO,EACb,KAAM,EAAO,EACb,KAAM,EAAO,EACb,WACE,eADE,YACS,SAGb,uBACD,sBAED,OAhDA,KAAM,EAEN,KAAK,KAAK,KAAN,EACF,GADiB,QAAK,QAEpB,QADE,YAAS,cACN,MAAQ,SAAW,SAExB,UAAK,MAAQ,QAAU,SAI3B,UAAI,IAAI,MACR,yCAAM,GAAS,KAAK,OAAS,GAAG,KAEhC,SAAO,GAAG,UAAW,UACnB,KAAI,IAAI,MAAM,iBAAkB,EAChC,MACD,UAED,KAAO,GAAG,iBAAmB,WAAS,IAC5B,GAAe,EAEvB,aACA,qBAAI,IAAI,MAAM,2BAA4B,EAAK,KAC/C,sBAAK,eAAe,EACrB,GAED,KAAO,GAAG,QAAS,WACjB,SAAQ,MACR,iCACD,gBAED,KAAO,GAAG,mBAAoB,WAAQ,IAC5B,GAAc,EACtB,cAAI,IAAI,MACR,yBACD,oBAED,KAWO,GACP,YAAO,GACR,iDAGC,KAAI,IAAI,MAAM,eAAgB,KAC9B,WAAK,OAAO,KAAK,WAAY,CAAE,KAAM,KACtC,wCAEiB,WAAW,OAC3B,WAAO,GAAU,IAEjB,eAEA,gBAAI,IAAI,MACR,mBAAM,GACN,KAAM,EAAU,IAAI,qBAGlB,IACA,QAAI,EAAW,SAAW,MAE1B,cAAM,GAEJ,UACC,WACC,GAAK,OAAO,KAAK,OACf,CACA,OACA,UACA,gBACA,OAEH,YAEH,KAAK,wBACH,EAAK,aACL,EAAK,eACL,EAGF,mBAAuB,UAvBzB,MAAK,GAAW,QAAW,OAwB1B,GAED,KAAI,IAAI,MAAM,QAAS,EAEvB,YACD,2DAEuB,WACtB,OAAO,CAAC,KAAK,gBAAkB,KAAO,GACvC,wCAEqB,WACpB,KAAI,IAAI,MACR,+BAAW,SACZ,6CAEqB,WACpB,KAAI,IAAI,MAA+B,0BAAU,KACjD,YAAW,SACX,cAAO,MACP,eAAO,MACP,kBACD,kDAEgB,WACf,IAAM,GAAO,KAEb,YAAa,WAAW,MAAO,KAAI,SAEnC,qBAAQ,EACN,iBAAK,GACH,mBAAO,KAAI,SAEb,iBAAK,GACH,iBAAO,KAAI,SAEb,eAAK,GACL,cACE,cAAO,KAAI,SAEhB,wCAEkB,eACjB,MAAW,SACZ,4CAE4B,eAC3B,IAAM,GACJ,MAAM,IACN,SACA,KACA,OACA,OAGF,iBAAK,OAAO,KACb,uCAEmB,aAClB,KAAK,GAAI,KAAY,MACnB,WAEH,uDAE6B,aAC5B,IAAM,GACJ,MAAM,IACN,SACA,OACA,OAEF,sBAAK,OAAO,KACb,6CAEc,UAYb,OAAO,SAAQ,OAChB,8FAEkB,OACjB,KAAM,EAAiB,KAAK,MAAQ,KAEpC,oBAAO,OAAM,SAAS,SAAS,KAAM,CAAE,OAAQ,OAAQ,MAAO,aAC3D,KAAK,WACJ,CACA,GAAI,GAAqB,GAAI,MAAK,EAAI,QAAQ,IAAI,SAAS,UAAa,IACxE,EAAI,EAAqB,KACrB,MACA,EADa,EAAsB,CAAsB,KAC7D,CAEA,KAEA,qBACE,EADE,IAAK,qBACF,YAEL,UAAK,YAAY,EAAK,mBAGxB,QAAK,cAAgB,EAAK,YAAY,OAAa,aAAN,OAAwB,KAAhD,EAAwD,GAAK,EAAK,YAEvF,OACE,EADE,GAAK,8BACI,iBAAM,GAAK,kBAEtB,YAEH,kBACJ,0CAGC,OAAO,CACR,WAGH,IAAI,SAAS,SAA0B,mBAEvC,EAAiB,uXCpRX,YACJ,CAA+B,iBAAgB,GAC7C,aACA,eACA,gBACA,sBACA,aAAK,aAEL,gCAAK,GAAK,KACV,4BAAK,QACN,sDAEqD,eACpD,MACA,oBACA,sBACD,iDAGC,IAAI,GAEJ,UAAK,aACH,KAAK,GAAG,kBAAkB,KAAK,aAAc,CAE/C,oBAAK,GAAG,YACG,WACP,GACD,2BAHH,EAIW,WACP,KAAI,IAAI,MACT,uBAEJ,+BAEY,WAEX,IAAI,KAAK,UAAY,EAAO,IAAM,KAAK,WAAa,EAEpD,YAAQ,EACN,UACE,aACA,eAEF,UACE,cACA,gBAEF,UACE,iBACA,mBAEF,MACE,YAAI,IAAI,MACN,gDAAkD,EAIzD,4BAEU,aACT,CAAqB,IAAjB,QAAK,SAIT,MAJ6B,QAAK,QAAQ,iBAIrC,QAAQ,KAAK,KAAK,UAAU,CAAQ,OAC1C,6CAGC,IAAqB,IAAjB,QAAK,QAAkB,MAAO,GAElC,qBAAQ,KAAK,QACX,gBACE,aAAO,GAET,iBACE,mBAAO,GAET,eACA,cACA,SACE,cAAO,GAEZ,eAED,+CAKE,IAAI,GACJ,KAAI,EACF,OAAO,mBACP,OAAO,yBACP,OAAO,sBACP,OAEF,uBACE,gBAAM,IAAI,OAKZ,qFAAI,GAAS,MAAkB,CAAE,WAAY,EAE7C,cAsBD,SAtBI,eAA0B,WAC3B,CAAI,EACF,aAAK,eACH,MAAM,EACN,WAAI,EACJ,cACA,0BAAe,EAAM,UACrB,wBAAW,EAAM,UAGtB,WAID,IAAG,2BAA6B,UAC9B,CAAI,EAAK,MACP,cADe,KAAG,uBAElB,UAAK,eAAe,EAEvB,UAED,gCAGW,WACX,IAAI,GAEJ,UAGA,eAAK,QAAQ,UAAqB,WAChC,IAAI,GAAO,KAAK,MAAM,EACtB,QAAK,gBAAgB,EAAK,SAAU,EAAK,KAAM,EAChD,KAGD,OAAK,QAAQ,OAAkB,UAC7B,GACA,UAAK,aAAa,EACnB,SAGD,OAAK,QAAQ,QAAmB,UAC1B,CAAC,EACL,SACA,UAAK,eAAe,EACrB,UAGD,OAAK,QAAQ,QAAmB,WAC9B,KAAI,IAAI,MACT,iCACF,6BAEW,WACV,IAAI,GAEJ,UAAK,GAAG,cAAyB,WAC/B,GAAK,aAAa,EACnB,QAED,OAEA,6BAAK,GAAG,aACG,WACP,GACD,2BAHH,EAIW,WACP,KAAI,IAAI,MACT,6BAEJ,+BAEY,WACX,MACD,uDAEe,WACd,IAAI,GACJ,KAAI,EACF,OAAO,iBACP,OAAO,uBACP,OAEF,wBAAK,GAAG,gBACc,SACpB,UAAa,CAFf,EAGW,WACP,KAAI,IAAI,MACT,iCAEJ,2CAEwB,WACnB,CAEJ,UAAK,GACH,sBACA,UAAa,CAFf,EAGW,WACP,KAAI,IAAI,MACT,0CAGH,QAAK,eACH,MAAM,KACN,WAAI,KACJ,cAAM,EACN,SAAK,EAER,0CAEoB,WACnB,IAAI,GACJ,KAAI,EACF,OAAO,uBACP,OAAO,6BACP,OAAO,0BACP,OAEF,6BAAK,GAAG,qBACoB,SAC1B,UAAa,CAFf,EAGW,WACP,KAAI,IAAI,MACT,sCAEJ,kCAGC,CAAI,KACF,SAAK,GAER,iBAGH,EAAW,aAAe,eAC1B,EAAW,WAAa,aACxB,EAAW,cAAgB,gBAE3B,EAAW,YAAc,CACvB,CAAE,KAAM,iCACR,CAAE,KAAM,iCACR,CAAE,KAAM,iCACR,CAAE,KAAM,kCAGV,EAAiB","file":"naf-native-webrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2f76baa1ec32f0b6d240","const WebRtcPeer = require(\"./WebRtcPeer\");\n\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nclass NativeWebRtcAdapter {\n  constructor() {\n\n    if (io === undefined)\n      console.warn('It looks like socket.io has not been loaded before NativeWebRtcAdapter. Please do that.')\n\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n\n    this.peers = {}; // id -> WebRtcPeer\n    this.occupants = {}; // id -> joinTimestamp\n  }\n\n  setServerUrl(wsUrl) {\n    this.wsUrl = wsUrl;\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n  }\n\n  setWebRtcOptions(options) {\n    if (options.datachannel === false)\n      console.warn(\n        \"NativeWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\n      );\n    if (options.audio === true)\n      console.warn(\"NativeWebRtcAdapter does not support audio yet.\");\n    if (options.video === true)\n      console.warn(\"NativeWebRtcAdapter does not support video yet.\");\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.occupantListener = occupantListener;\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  connect() {\n    const self = this;\n\n    if (!this.wsUrl || this.wsUrl === \"/\") {\n      if (location.protocol === \"https:\") {\n        this.wsUrl = \"wss://\" + location.host;\n      } else {\n        this.wsUrl = \"ws://\" + location.host;\n      }\n    }\n\n    NAF.log.write(\"Attempting to connect to socket.io\");\n    const socket = this.socket = io(this.wsUrl);\n\n    socket.on(\"connect\", () => {\n      NAF.log.write(\"User connected\", socket.id);\n      self.joinRoom();\n    });\n\n    socket.on(\"connectSuccess\", (data) => {\n      const { joinedTime } = data;\n\n      this.myRoomJoinTime = joinedTime;\n      NAF.log.write(\"Successfully joined room\", this.room, \"at server time\", joinedTime);\n      self.connectSuccess(socket.id);\n    });\n\n    socket.on(\"error\", err => {\n      console.error(\"Socket connection failure\", err);\n      self.connectFailure();\n    });\n\n    socket.on(\"occupantsChanged\", data => {\n      const { occupants } = data;\n      NAF.log.write('occupants changed', data);\n      self.receivedOccupants(occupants);\n    });\n\n    function receiveData(packet) {\n      const from = packet.from;\n      const type = packet.type;\n      const data = packet.data;\n      if (type === 'ice-candidate') {\n        self.peers[from].handleSignal(data);\n        return;\n      }\n      self.messageListener(from, type, data);\n    }\n\n    socket.on(\"send\", receiveData);\n    socket.on(\"broadcast\", receiveData);\n  }\n\n  joinRoom() {\n    NAF.log.write(\"Joining room\", this.room);\n    this.socket.emit(\"joinRoom\", { room: this.room });\n  }\n\n  receivedOccupants(occupants) {\n    delete occupants[NAF.clientId];\n\n    this.occupants = occupants;\n\n    NAF.log.write('occupants=', occupants);\n    const self = this;\n    const localId = NAF.clientId;\n\n    for (var key in occupants) {\n      const remoteId = key;\n      if (this.peers[remoteId]) continue;\n\n      const peer = new WebRtcPeer(\n        localId,\n        remoteId,\n        (data) => {\n          self.socket.emit('send',{\n            from: localId,\n            to: remoteId,\n            type: 'ice-candidate',\n            data,\n            sending: true,\n          });\n        }\n      );\n      peer.setDatachannelListeners(\n        self.openListener,\n        self.closedListener,\n        self.messageListener\n      );\n\n      self.peers[remoteId] = peer;\n    }\n\n    NAF.log.write('peers', self.peers);\n\n    this.occupantListener(occupants);\n  }\n\n  shouldStartConnectionTo(client) {\n    return (this.myRoomJoinTime || 0) <= (client || 0);\n  }\n\n  startStreamConnection(remoteId) {\n    NAF.log.write('starting offer process');\n    this.peers[remoteId].offer();\n  }\n\n  closeStreamConnection(clientId) {\n    NAF.log.write('closeStreamConnection', clientId, this.peers);\n    this.peers[clientId].close();\n    delete this.peers[clientId];\n    delete this.occupants[clientId];\n    this.closedListener(clientId);\n  }\n\n  getConnectStatus(clientId) {\n    const peer = this.peers[clientId];\n\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\n\n    switch (peer.getStatus()) {\n      case WebRtcPeer.IS_CONNECTED:\n        return NAF.adapters.IS_CONNECTED;\n\n      case WebRtcPeer.CONNECTING:\n        return NAF.adapters.CONNECTING;\n\n      case WebRtcPeer.NOT_CONNECTED:\n      default:\n        return NAF.adapters.NOT_CONNECTED;\n    }\n  }\n\n  sendData(to, type, data) {\n    this.peers[to].send(type, data);\n  }\n\n  sendDataGuaranteed(to, type, data) {\n    const packet = {\n      from: NAF.clientId,\n      to,\n      type,\n      data,\n      sending: true,\n    };\n\n    this.socket.emit(\"send\", packet);\n  }\n\n  broadcastData(type, data) {\n    for (var clientId in this.peers) {\n      this.sendData(clientId, type, data);\n    }\n  }\n\n  broadcastDataGuaranteed(type, data) {\n    const packet = {\n      from: NAF.clientId,\n      type,\n      data,\n      broadcasting: true\n    };\n    this.socket.emit(\"broadcast\", packet);\n  }\n\n  getMediaStream(clientId) {\n    // TODO implement audio\n    // var that = this;\n    // if (this.audioStreams[clientId]) {\n    //   NAF.log.write(\"Already had audio for \" + clientId);\n    //   return Promise.resolve(this.audioStreams[clientId]);\n    // } else {\n    //   NAF.log.write(\"Waiting on audio for \" + clientId);\n    //   return new Promise(function(resolve) {\n    //     that.pendingAudioRequest[clientId] = resolve;\n    //   });\n    // }\n    return Promise.reject('Interface method not implemented: getMediaStream')\n  }\n\n  updateTimeOffset() {\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  getServerTime() {\n    return -1; // TODO implement\n  }\n}\n\nNAF.adapters.register(\"native-webrtc\", NativeWebRtcAdapter);\n\nmodule.exports = NativeWebRtcAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","class WebRtcPeer {\n  constructor(localId, remoteId, sendSignalFunc) {\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  setDatachannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  offer() {\n    var self = this;\n    // reliable: false - UDP\n    this.setupChannel(\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\n    );\n    this.pc.createOffer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.offer: \" + error);\n      }\n    );\n  }\n\n  handleSignal(signal) {\n    // ignores signal if it isn't for me\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n    switch (signal.type) {\n      case \"offer\":\n        this.handleOffer(signal);\n        break;\n\n      case \"answer\":\n        this.handleAnswer(signal);\n        break;\n\n      case \"candidate\":\n        this.handleCandidate(signal);\n        break;\n\n      default:\n        NAF.log.error(\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\n        );\n        break;\n    }\n  }\n\n  send(type, data) {\n    if (this.channel === null || this.channel.readyState !== \"open\") {\n      return;\n    }\n\n    this.channel.send(JSON.stringify({ type: type, data: data }));\n  }\n\n  getStatus() {\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n    switch (this.channel.readyState) {\n      case \"open\":\n        return WebRtcPeer.IS_CONNECTED;\n\n      case \"connecting\":\n        return WebRtcPeer.CONNECTING;\n\n      case \"closing\":\n      case \"closed\":\n      default:\n        return WebRtcPeer.NOT_CONNECTED;\n    }\n  }\n\n  /*\n   * Privates\n   */\n\n  createPeerConnection() {\n    var self = this;\n    var RTCPeerConnection =\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection ||\n      window.msRTCPeerConnection;\n\n    if (RTCPeerConnection === undefined) {\n      throw new Error(\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\n      );\n    }\n\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\n\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        self.sendSignalFunc({\n          from: self.localId,\n          to: self.remoteId,\n          type: \"candidate\",\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          candidate: event.candidate.candidate\n        });\n      }\n    };\n\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\n    //       so also tries to detect disconnection here.\n    pc.oniceconnectionstatechange = function() {\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }\n    };\n\n    return pc;\n  }\n\n  setupChannel(channel) {\n    var self = this;\n\n    this.channel = channel;\n\n    // received data from a remote peer\n    this.channel.onmessage = function(event) {\n      var data = JSON.parse(event.data);\n      self.messageListener(self.remoteId, data.type, data.data);\n    };\n\n    // connected with a remote peer\n    this.channel.onopen = function(event) {\n      self.open = true;\n      self.openListener(self.remoteId);\n    };\n\n    // disconnected with a remote peer\n    this.channel.onclose = function(event) {\n      if (!self.open) return;\n      self.open = false;\n      self.closedListener(self.remoteId);\n    };\n\n    // error occurred with a remote peer\n    this.channel.onerror = function(error) {\n      NAF.log.error(\"WebRtcPeer.channel.onerror: \" + error);\n    };\n  }\n\n  handleOffer(message) {\n    var self = this;\n\n    this.pc.ondatachannel = function(event) {\n      self.setupChannel(event.channel);\n    };\n\n    this.setRemoteDescription(message);\n\n    this.pc.createAnswer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleOffer: \" + error);\n      }\n    );\n  }\n\n  handleAnswer(message) {\n    this.setRemoteDescription(message);\n  }\n\n  handleCandidate(message) {\n    var self = this;\n    var RTCIceCandidate =\n      window.RTCIceCandidate ||\n      window.webkitRTCIceCandidate ||\n      window.mozRTCIceCandidate;\n\n    this.pc.addIceCandidate(\n      new RTCIceCandidate(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleCandidate: \" + error);\n      }\n    );\n  }\n\n  handleSessionDescription(sdp) {\n    var self = this;\n\n    this.pc.setLocalDescription(\n      sdp,\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      }\n    );\n\n    this.sendSignalFunc({\n      from: this.localId,\n      to: this.remoteId,\n      type: sdp.type,\n      sdp: sdp.sdp\n    });\n  }\n\n  setRemoteDescription(message) {\n    var self = this;\n    var RTCSessionDescription =\n      window.RTCSessionDescription ||\n      window.webkitRTCSessionDescription ||\n      window.mozRTCSessionDescription ||\n      window.msRTCSessionDescription;\n\n    this.pc.setRemoteDescription(\n      new RTCSessionDescription(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      }\n    );\n  }\n\n  close() {\n    if (this.pc) {\n      this.pc.close();\n    }\n  }\n}\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\n\nWebRtcPeer.ICE_SERVERS = [\n  { urls: \"stun:stun1.l.google.com:19302\" },\n  { urls: \"stun:stun2.l.google.com:19302\" },\n  { urls: \"stun:stun3.l.google.com:19302\" },\n  { urls: \"stun:stun4.l.google.com:19302\" }\n];\n\nmodule.exports = WebRtcPeer;\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}