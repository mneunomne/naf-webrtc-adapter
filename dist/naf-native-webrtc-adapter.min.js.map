{"version":3,"sources":["webpack:///webpack/bootstrap db260fe89bea15071fb5","webpack:///./src/index.js","webpack:///./src/WebRtcPeer.js"],"names":["WebRtcPeer","require","NativeWebRtcAdapter","console","wsUrl","appName","roomName","options","NAF","successListener","occupantListener","openListener","self","from","packet","type","data","location","socket","io","navigator","video","room","occupants","localId","peer","sending","client","remoteId","localAudioStream","clientId","to","broadcasting","that","Promise","clientSentTime","Date","document","method","cache","serverReceivedTime","res","precision","clientReceivedTime","timeOffset","setTimeout","module","offerToReceiveVideo","signal","JSON","RTCPeerConnection","window","pc","iceServers","event","sdpMLineIndex","candidate","e","channel","message","RTCIceCandidate","sdp","RTCSessionDescription","urls"],"mappings":"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","file":"naf-native-webrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap db260fe89bea15071fb5","const WebRtcPeer = require(\"./WebRtcPeer\");\n\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nclass NativeWebRtcAdapter {\n  constructor() {\n    if (io === undefined)\n      console.warn('It looks like socket.io has not been loaded before NativeWebRtcAdapter. Please do that.')\n\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n    this.myId = null;\n    this.avgTimeOffset = 0;\n\n    this.peers = {}; // id -> WebRtcPeer\n    this.occupants = {}; // id -> joinTimestamp\n\n    this.audioStreams = {};\n    this.pendingAudioRequest = {};\n\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  setServerUrl(wsUrl) {\n    this.wsUrl = wsUrl;\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n  }\n\n  setWebRtcOptions(options) {\n    if (options.datachannel === false) {\n      NAF.log.error(\n        \"NativeWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\n      );\n    }\n    if (options.audio === true) {\n      this.sendAudio = true;\n    }\n    if (options.video === true) {\n      NAF.log.warn(\"NativeWebRtcAdapter does not support video yet.\");\n    }\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.occupantListener = occupantListener;\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n  }\n\n  connect() {\n    const self = this;\n\n    this.updateTimeOffset()\n    .then(() => {\n      if (!self.wsUrl || self.wsUrl === \"/\") {\n        if (location.protocol === \"https:\") {\n          self.wsUrl = \"wss://\" + location.host;\n        } else {\n          self.wsUrl = \"ws://\" + location.host;\n        }\n      }\n  \n      NAF.log.write(\"Attempting to connect to socket.io\");\n      const socket = self.socket = io(self.wsUrl);\n  \n      socket.on(\"connect\", () => {\n        NAF.log.write(\"User connected\", socket.id);\n        self.myId = socket.id;\n        self.joinRoom();\n      });\n  \n      socket.on(\"connectSuccess\", (data) => {\n        const { joinedTime } = data;\n  \n        self.myRoomJoinTime = joinedTime;\n        NAF.log.write(\"Successfully joined room\", self.room, \"at server time\", joinedTime);\n  \n        if (self.sendAudio) {\n          const mediaConstraints = {\n            audio: true,\n            video: false\n          };\n          navigator.mediaDevices.getUserMedia(mediaConstraints)\n          .then(localStream => {\n            self.storeAudioStream(self.myId, localStream);\n            self.connectSuccess(self.myId);\n          })\n          .catch(e => NAF.log.error(e));\n        } else {\n          self.connectSuccess(self.myId);\n        }\n      });\n  \n      socket.on(\"error\", err => {\n        console.error(\"Socket connection failure\", err);\n        self.connectFailure();\n      });\n  \n      socket.on(\"occupantsChanged\", data => {\n        const { occupants } = data;\n        NAF.log.write('occupants changed', data);\n        self.receivedOccupants(occupants);\n      });\n  \n      function receiveData(packet) {\n        const from = packet.from;\n        const type = packet.type;\n        const data = packet.data;\n        if (type === 'ice-candidate') {\n          self.peers[from].handleSignal(data);\n          return;\n        }\n        self.messageListener(from, type, data);\n      }\n  \n      socket.on(\"send\", receiveData);\n      socket.on(\"broadcast\", receiveData);\n    })\n\n\n  }\n\n  joinRoom() {\n    NAF.log.write(\"Joining room\", this.room);\n    this.socket.emit(\"joinRoom\", { room: this.room });\n  }\n\n  receivedOccupants(occupants) {\n    delete occupants[this.myId];\n\n    this.occupants = occupants;\n\n    NAF.log.write('occupants=', occupants);\n    const self = this;\n    const localId = this.myId;\n\n    for (var key in occupants) {\n      const remoteId = key;\n      if (this.peers[remoteId]) continue;\n\n      const peer = new WebRtcPeer(\n        localId,\n        remoteId,\n        (data) => {\n          self.socket.emit('send',{\n            from: localId,\n            to: remoteId,\n            type: 'ice-candidate',\n            data,\n            sending: true,\n          });\n        }\n      );\n      peer.setDatachannelListeners(\n        self.openListener,\n        self.closedListener,\n        self.messageListener,\n        self.trackListener.bind(self)\n      );\n\n      self.peers[remoteId] = peer;\n    }\n\n    this.occupantListener(occupants);\n  }\n\n  shouldStartConnectionTo(client) {\n    return (this.myRoomJoinTime || 0) <= (client || 0);\n  }\n\n  startStreamConnection(remoteId) {\n    NAF.log.write('starting offer process');\n\n    if (this.sendAudio) {\n      this.getMediaStream(this.myId)\n      .then(stream => {\n        const options = {\n          sendAudio: true,\n          localAudioStream: stream,\n        };\n        this.peers[remoteId].offer(options);\n      });\n    } else {\n      this.peers[remoteId].offer({});\n    }\n  }\n\n  closeStreamConnection(clientId) {\n    NAF.log.write('closeStreamConnection', clientId, this.peers);\n    this.peers[clientId].close();\n    delete this.peers[clientId];\n    delete this.occupants[clientId];\n    this.closedListener(clientId);\n  }\n\n  getConnectStatus(clientId) {\n    const peer = this.peers[clientId];\n\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\n\n    switch (peer.getStatus()) {\n      case WebRtcPeer.IS_CONNECTED:\n        return NAF.adapters.IS_CONNECTED;\n\n      case WebRtcPeer.CONNECTING:\n        return NAF.adapters.CONNECTING;\n\n      case WebRtcPeer.NOT_CONNECTED:\n      default:\n        return NAF.adapters.NOT_CONNECTED;\n    }\n  }\n\n  sendData(to, type, data) {\n    this.peers[to].send(type, data);\n  }\n\n  sendDataGuaranteed(to, type, data) {\n    const packet = {\n      from: this.myId,\n      to,\n      type,\n      data,\n      sending: true,\n    };\n\n    this.socket.emit(\"send\", packet);\n  }\n\n  broadcastData(type, data) {\n    for (var clientId in this.peers) {\n      this.sendData(clientId, type, data);\n    }\n  }\n\n  broadcastDataGuaranteed(type, data) {\n    const packet = {\n      from: this.myId,\n      type,\n      data,\n      broadcasting: true\n    };\n    this.socket.emit(\"broadcast\", packet);\n  }\n\n  storeAudioStream(clientId, stream) {\n    this.audioStreams[clientId] = stream;\n    if (this.pendingAudioRequest[clientId]) {\n      NAF.log.write(\"Received pending audio for \" + clientId);\n      this.pendingAudioRequest[clientId](stream);\n      delete this.pendingAudioRequest[clientId](stream);\n    }\n  }\n\n  trackListener(clientId, stream) {\n    this.storeAudioStream(clientId, stream);\n  }\n\n  getMediaStream(clientId) {\n    var that = this;\n    if (this.audioStreams[clientId]) {\n      NAF.log.write(\"Already had audio for \" + clientId);\n      return Promise.resolve(this.audioStreams[clientId]);\n    } else {\n      NAF.log.write(\"Waiting on audio for \" + clientId);\n      return new Promise(resolve => {\n        that.pendingAudioRequest[clientId] = resolve;\n      });\n    }\n  }\n\n  updateTimeOffset() {\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  getServerTime() {\n    return -1; // TODO implement\n  }\n}\n\nNAF.adapters.register(\"native-webrtc\", NativeWebRtcAdapter);\n\nmodule.exports = NativeWebRtcAdapter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","class WebRtcPeer {\n  constructor(localId, remoteId, sendSignalFunc) {\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  setDatachannelListeners(openListener, closedListener, messageListener, trackListener) {\n    this.openListener = openListener;\n    this.closedListener = closedListener;\n    this.messageListener = messageListener;\n    this.trackListener = trackListener;\n  }\n\n  offer(options) {\n    var self = this;\n    // reliable: false - UDP\n    this.setupChannel(\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\n    );\n\n    // If there are errors with Safari implement this:\n    // https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/OpenViduInternal/WebRtcPeer/WebRtcPeer.ts#L154\n    \n    if (options.sendAudio) {\n      options.localAudioStream.getTracks().forEach(\n        track => self.pc.addTrack(track, options.localAudioStream));\n    }\n\n    this.pc.createOffer(\n      sdp => {\n        self.handleSessionDescription(sdp);\n      },\n      error => {\n        NAF.log.error(\"WebRtcPeer.offer: \" + error);\n      },\n      {\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      }\n    );\n  }\n\n  handleSignal(signal) {\n    // ignores signal if it isn't for me\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n    switch (signal.type) {\n      case \"offer\":\n        this.handleOffer(signal);\n        break;\n\n      case \"answer\":\n        this.handleAnswer(signal);\n        break;\n\n      case \"candidate\":\n        this.handleCandidate(signal);\n        break;\n\n      default:\n        NAF.log.error(\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\n        );\n        break;\n    }\n  }\n\n  send(type, data) {\n    if (this.channel === null || this.channel.readyState !== \"open\") {\n      return;\n    }\n\n    this.channel.send(JSON.stringify({ type: type, data: data }));\n  }\n\n  getStatus() {\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n    switch (this.channel.readyState) {\n      case \"open\":\n        return WebRtcPeer.IS_CONNECTED;\n\n      case \"connecting\":\n        return WebRtcPeer.CONNECTING;\n\n      case \"closing\":\n      case \"closed\":\n      default:\n        return WebRtcPeer.NOT_CONNECTED;\n    }\n  }\n\n  /*\n   * Privates\n   */\n\n  createPeerConnection() {\n    var self = this;\n    var RTCPeerConnection =\n      window.RTCPeerConnection ||\n      window.webkitRTCPeerConnection ||\n      window.mozRTCPeerConnection ||\n      window.msRTCPeerConnection;\n\n    if (RTCPeerConnection === undefined) {\n      throw new Error(\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\n      );\n    }\n\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\n\n    pc.onicecandidate = function(event) {\n      if (event.candidate) {\n        self.sendSignalFunc({\n          from: self.localId,\n          to: self.remoteId,\n          type: \"candidate\",\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          candidate: event.candidate.candidate\n        });\n      }\n    };\n\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\n    //       so also tries to detect disconnection here.\n    pc.oniceconnectionstatechange = function() {\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }\n    };\n\n    pc.ontrack = (e) => {\n      self.trackListener(self.remoteId, e.streams[0]);\n    }\n\n    return pc;\n  }\n\n  setupChannel(channel) {\n    var self = this;\n\n    this.channel = channel;\n\n    // received data from a remote peer\n    this.channel.onmessage = function(event) {\n      var data = JSON.parse(event.data);\n      self.messageListener(self.remoteId, data.type, data.data);\n    };\n\n    // connected with a remote peer\n    this.channel.onopen = function(event) {\n      self.open = true;\n      self.openListener(self.remoteId);\n    };\n\n    // disconnected with a remote peer\n    this.channel.onclose = function(event) {\n      if (!self.open) return;\n      self.open = false;\n      self.closedListener(self.remoteId);\n    };\n\n    // error occurred with a remote peer\n    this.channel.onerror = function(error) {\n      NAF.log.error(\"WebRtcPeer.channel.onerror: \" + error);\n    };\n  }\n\n  handleOffer(message) {\n    var self = this;\n\n    this.pc.ondatachannel = function(event) {\n      self.setupChannel(event.channel);\n    };\n\n    this.setRemoteDescription(message);\n\n    this.pc.createAnswer(\n      function(sdp) {\n        self.handleSessionDescription(sdp);\n      },\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleOffer: \" + error);\n      }\n    );\n  }\n\n  handleAnswer(message) {\n    this.setRemoteDescription(message);\n  }\n\n  handleCandidate(message) {\n    var self = this;\n    var RTCIceCandidate =\n      window.RTCIceCandidate ||\n      window.webkitRTCIceCandidate ||\n      window.mozRTCIceCandidate;\n\n    this.pc.addIceCandidate(\n      new RTCIceCandidate(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleCandidate: \" + error);\n      }\n    );\n  }\n\n  handleSessionDescription(sdp) {\n    var self = this;\n\n    this.pc.setLocalDescription(\n      sdp,\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      }\n    );\n\n    this.sendSignalFunc({\n      from: this.localId,\n      to: this.remoteId,\n      type: sdp.type,\n      sdp: sdp.sdp\n    });\n  }\n\n  setRemoteDescription(message) {\n    var self = this;\n    var RTCSessionDescription =\n      window.RTCSessionDescription ||\n      window.webkitRTCSessionDescription ||\n      window.mozRTCSessionDescription ||\n      window.msRTCSessionDescription;\n\n    this.pc.setRemoteDescription(\n      new RTCSessionDescription(message),\n      function() {},\n      function(error) {\n        NAF.log.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      }\n    );\n  }\n\n  close() {\n    if (this.pc) {\n      this.pc.close();\n    }\n  }\n}\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\n\nWebRtcPeer.ICE_SERVERS = [\n  { urls: \"stun:stun1.l.google.com:19302\" },\n  { urls: \"stun:stun2.l.google.com:19302\" },\n  { urls: \"stun:stun3.l.google.com:19302\" },\n  { urls: \"stun:stun4.l.google.com:19302\" }\n];\n\nmodule.exports = WebRtcPeer;\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}